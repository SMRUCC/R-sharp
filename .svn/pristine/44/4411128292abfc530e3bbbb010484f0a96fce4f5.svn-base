<?xml version="1.0"?>
<doc>
<assembly>
<name>
Microsoft.VisualBasic.Scripting.ShoalShell
</name>
</assembly>
<members>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Compiler.CodeDOM.Program.__castType(System.CodeDom.CodeExpression,System.Type)">
 <summary>
 与公共框架里面的方法所不同的是，这个类型的转换方法会实现Shoal脚本语言之中的更加动态的类型转换
 </summary>
 <param name="value"></param>
 <param name="typeRef"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Compiler.CodeDOM.Program.__return(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Return)">
 <summary>
 请注意，由于函数的返回值是<see cref="T:System.Int32"/>类型，所以这里的数据类型转换总是转换至整形数的
 </summary>
 <param name="Expr"></param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Configuration.Configuration">
 <summary>
 配置数据的设置引擎
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Configuration.Config">
 <summary>
 脚本引擎的配置文件
 </summary>
 
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Configuration.Config.InitDir">
 <summary>
 应用程序启动的时候的初始工作目录，默认为应用程序所在的文件夹
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Configuration.Config.SPMRegistry">
 <summary>
 脚本引擎的类型注册表的文件位置，为空的话会使用默认的文件位置
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Configuration.Config.GetRegistryFile">
 <summary>
 Get shoal shell registry file path.(获取注册表的文件路径)
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.DocRenderer">
 <summary>
 命名空间的html帮助页面的生成工具
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.DocRenderer.RequestHtml(Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Namespace)">
 <summary>
 值返回路径
 </summary>
 <param name="[Namespace]"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.IWikiHandle">
 <summary>
 Internal wiki system queriable object.(这个对象是可以接受wiki查询操作的)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.IWikiHandle.Match(System.String)">
 <summary>
 模糊匹配并返回匹配结果，当返回空字符串的时候，则说明没有被匹配上
 </summary>
 <param name="keyword"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.Wiki.WikiSearchView(System.String)">
 <summary>
 
 </summary>
 <param name="obj">所需要搜索帮助信息的对象的名称</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.Wiki.WikiHelp">
 <summary>
 不带任何参数的wiki命令，显示概览信息
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.HTML.Wiki.__listAllImportsAPI">
 <summary>
 打印出所有导入的API的信息
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.AnonymousDelegate">
 <summary>
 匿名函数
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.AnonymousDelegate.CdTemp">
 <summary>
 当切换目录之后扫描当前目录之下的所有的临时命令脚本
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.AnonymousDelegate.Exec(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls,System.Boolean@)">
 <summary>
 
 </summary>
 <param name="Expr"></param>
 <param name="success">这个变量主要是用来指示是否找到了相应的函数入口点</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.AnonymousDelegate.GetScriptDelegate(System.String)">
 <summary>
 会在两个字典之中进行查找，由于可能会因为不小心重名的缘故会造成临时脚本被执行，产生无法察觉的BUG，所以在这里临时脚本命令的优先级是最低的
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Interpreter">
 <summary>
 Parsing the script text into a LDM data model for the script executing. 
 </summary>
 <remarks>
 命令行输入的脚本行，一般认为是完整的一行，则直接使用<see cref="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Interpreter.InternalExpressionParser(System.String)"/>来解析
 从脚本文件之中输入的脚本文件可能含有Delegate函数或者多行的数组定义，则脚本文件是使用<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.MSLTokens"/>来解析的
 </remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Interpreter.ParseFile(System.String)">
 <summary>
 使用<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.MSLTokens"/>来解析
 </summary>
 <param name="File">文件路径</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Interpreter.MSLParser(System.String)">
 <summary>
 处理来自于文件之中的可能具有多行分行的脚本代码
 </summary>
 <param name="Script"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Interpreter.InternalExpressionParser(System.String)">
 <summary>
 处理来自于终端输入的只有一行的脚本代码
 </summary>
 <param name="Line"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls">
 <summary>
 所输入的参数是可能没有顺序的，但是函数的参数定义是有顺序的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.OrderReferenceAlignment(System.Reflection.ParameterInfo[],System.Object[])">
 <summary>
 一一对应比较
 </summary>
 <param name="FuncDef"></param>
 <param name="InputParam"></param>
 <returns></returns>
 <remarks>一一对应比较和参数名无关</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.__boolsEquals(System.Reflection.ParameterInfo,System.Object)">
 <summary>
 处理逻辑开关标记的
 </summary>
 <param name="FuncDef"></param>
 <param name="inputParam"></param>
 <returns>函数不会计算拓展函数的调用参数</returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.OverloadsAlignment(System.Reflection.MethodInfo,System.Collections.Generic.KeyValuePair{System.String,System.Object}[])">
 <summary>
 使用这个函数来进行判断
 </summary>
 <param name="FuncDef"></param>
 <param name="InputParam"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.OverloadsAlignment(System.Reflection.MethodInfo,System.Collections.Generic.Dictionary{System.String,System.Object})">
 <summary>
 
 </summary>
 <param name="FuncDef"></param>
 <param name="InputParam"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.MultipleAlignment(System.Reflection.ParameterInfo[],System.Collections.Generic.Dictionary{System.String,System.Object}@)">
 <summary>
 
 </summary>
 <param name="FuncDef"></param>
 <param name="InputParam"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.OrderAlignment(System.Reflection.ParameterInfo[],System.Collections.Generic.Dictionary{System.String,System.Object}@)">
 <summary>
 输入的参数里面是没有任何的特殊的名称的，会使用字典查询，不会像<see cref="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.FunctionCalls.OrderReferenceAlignment(System.Reflection.ParameterInfo[],System.Object[])"/>
 </summary>
 <param name="FuncDef"></param>
 <param name="InputParam"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.TypeEquals">
 <summary>
 这个模块只是用来判断函数如何重载的，数据类型的转换有系统自动完成
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.TypeEquals.TypeEquals(System.Type,System.Type)">
 <summary>
 判断两种类型是否相等
 </summary>
 <param name="FuncDef">当前的这个重载方法的参数定义的类型</param>
 <param name="InputParam">从脚本传递进来的函数参数的类型</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.TypeEquals.IsInheritsFrom(System.Type,System.Type)">
 <summary>
 Is a inherits from b
 </summary>
 <param name="a">继承类型继承自基本类型，具备有基本类型的所有特性</param>
 <param name="b">基本类型</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.Alignment.TypeEquals.IsInterfaceInheritsFrom(System.Type,System.Type)">
 <summary>
 Is a inherits from b
 </summary>
 <param name="a">继承类型继承自基本类型，具备有基本类型的所有特性</param>
 <param name="b">基本类型</param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint">
 <summary>
 命令执行的入口点，使用这个对象进行函数重载的处理
 </summary>
 <remarks>
 重载函数的签名冲突的条件：
 1. 具有完全一样的参数列表，即参数名和参数类型完全一致，参数的顺序对签名冲突没有影响
 2. 除了满足上面的条件，两个函数之间的返回值完全一样的时候，即可认为两个函数的签名完全一样
 </remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint._OverloadAPIEntryPoints">
 <summary>
 Shoal脚本命令的函数重载
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.Name">
 <summary>
 Shoal API命令的名称
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.IsOverloaded">
 <summary>
 当前的这个执行入口点是否有重载的命令
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.#ctor(System.String,System.Reflection.MethodInfo)">
 <summary>
 共享方法
 </summary>
 <param name="Name"></param>
 <param name="InitMethod">如果不知道该怎么处理这个参数，请使用Nothing</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.#ctor(System.String,Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.CommandEntryPointInfo)">
 <summary>
 共享方法和实例方法
 </summary>
 <param name="Name"></param>
 <param name="InitEntryPoint">如果不知道该怎么处理这个参数，请使用Nothing</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.OverloadsAPIEntryPoint(Microsoft.VisualBasic.CommandLine.Reflection.EntryPoints.CommandEntryPointInfo)">
 <summary>
 向当前的执行入口点添加一个重载函数，当当前的执行入口点之中具备有两个完全相同的函数签名的入口点的时候，新的入口点会替换掉旧的入口点
 </summary>
 <param name="EntryPoint"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.__getTypeSignatureHandles(System.Reflection.MethodInfo)">
 <summary>
 获取用于支持函授重载所需要的数字签名信息
 </summary>
 <param name="EntryInfo"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint.OverloadsNumber">
 <summary>
 Overloads Entry Point Counts. (当前的这个执行入口点之中的重载的函数的反射入口点的数目)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIInvoker.TryInvoke(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.APIEntryPoint,System.Object[])">
 <summary>
 参数的位置适合函数的定义是一一对应的
 </summary>
 <param name="API"></param>
 <param name="args"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint">
 <summary>
 用于表示一个已经被签名的函数
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint._InternalParameterSignature">
 <summary>
 参数列表按照从小到大排序之后计算MD5哈希值作为参数列表的数字签名
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint.TypeSignature">
 <summary>
 返回值的数字签名
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint.FakeSingleParameter">
 <summary>
 当参数有多个的时候，出了第一个之外，其他的参数都是可选的或者类型为逻辑值，则该函数被定义为伪单参数函数
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint.ParameterSignature">
 <summary>
 参数列表按照从小到大排序之后计算MD5哈希值作为参数列表的数字签名
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint._InternalNonOptionalCounts">
 <summary>
 非可选参数的数目
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint.CreateObject(System.Reflection.MethodInfo,Microsoft.VisualBasic.Scripting.EntryPointMetaData.OverloadsSignatureHandle[])">
 <summary>
 创建共享方法的签名实例
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.APIHandler.SignatureSignedFunctionEntryPoint.Equals(System.Object)">
 <summary>
 判断两个函数入口点对象是否具有完全一样的数字签名
 </summary>
 <param name="obj"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.Linker.GetAddress(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable)">
 <summary>
 得到内存之中的实际引用位置
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.EntryPoint.TryGetEntryPoint(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.EntryPoint,System.String@)">
 <summary>
 
 </summary>
 <param name="EntryPoint"></param>
 <param name="execName">主要是为了方便查找函数指针的，因为后面可以直接使用这个变量而不需要再计算一遍了</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Linker.EntryPoint.ImportsInstance``1(``0)">
 <summary>
 请使用这个方法导入实例对象之中的定义的命令
 </summary>
 <param name="InvokedObject"></param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.CollectionOpr">
 <summary>
 Dim array &lt;= {expression} as type 
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Driver.DynamicsCast">
 <summary>
 var &lt; (typeID) {expression}
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Driver.DynamicsCast.TypeID">
 <summary>
 去掉了外层的括号了的
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Driver.FileIO.Value">
 <summary>
 左端的将要写入文件的表达式
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Driver.OutDeviceRef">
 <summary>
 解析出来的表达式之中只含有一个词元，并且不是注释，则默认认为是变量查看操作，值默认赋值给系统变量$
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.DynamicsExpression">
 <summary>
 在解释器阶段由于缺少信息还无法判断表达式的类型，则这些语句都被设定为动态的类型
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Die">
 <summary>
 Throw Exception
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Die.When">
 <summary>
 Boolean Expression
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Comments.CommentFLAGLen(System.String)">
 <summary>
 -1表示不是注释
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ControlFlows.GOTO">
 <summary>
 Goto语句
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ControlFlows.GOTO.ExprWhen">
 <summary>
 When后面的逻辑条件表达式
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ControlFlows.LineLabel">
 <summary>
 Goto的标签
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.HybridScript.RedirectStream">
 <summary>
 @name
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.HybridScript.HybridsScript.ExternalScript">
 <summary>
 计算得到脚本值，再由引擎计算值之后赋值给本脚本之中的变量
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.HybridScript.HybirdsScriptPush.InternalExpression">
 <summary>
 将要传递给外部变量的左端的表达式
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.HybridScript.HybirdsScriptPush.ExternalVariable">
 <summary>
 右端的外部变量的名称
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Memory.var">
 <summary>
 想要查看的变量详细信息的变量的名称，为空则打印出所有变量的摘要
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.OnErrorResumeNext">
 <summary>
 On Error Resume Next.(脚本程序在遇到错误之后忽略掉错误尝试继续执行下去)
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Imports">
 <summary>
 Imports Namespace1, Namespace2, Namespace3 
 (使用本方法导入外部命令，这样子就可以直接调用方法而不需要每一个命令行都添加模块名称了)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Imports.Namespaces">
 <summary>
 字符串常量或者内部表达式
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.SyntaxError.IsBlankLineSyntax">
 <summary>
 对于空白行，是无法被解析出来的，但是空白行不是语法错误
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Include">
 <summary>
 Include file1, file2, file3, file4, ...
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Include.ExternalScripts">
 <summary>
 The file path list of the external script
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Library">
 <summary>
 Dynamics install a external module in the runtime.
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Source">
 <summary>
 var &lt;= ${path argvs}
 这个语法是函数<see cref="M:Microsoft.VisualBasic.Scripting.ShoalShell.InternalExtension.Source(System.String,System.Collections.Generic.KeyValuePair{System.String,System.Object}[])"/>函数的简写形式
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.VariableDeclaration.Name">
 <summary>
 The name of the variable.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.VariableDeclaration.Type">
 <summary>
 变量的类型约束
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.IsNonExecuteCode">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.BlankLine"/>, <see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.Comments"/>, 
 <see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.SyntaxError"/>, <see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.LineLable"/>.
 (这个表达式是否为非执行代码)
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.ExprTypeID">
 <summary>
 表达式的类型编号
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.LineNumber">
 <summary>
 本句代码在脚本之中的原始的行数
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.Comments">
 <summary>
 语句后面所出现的注释信息
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.PrimaryExpression">
 <summary>
 原始的表达式字符串
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.SyntaxError">
 <summary>
 语法错误
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.BlankLine">
 <summary>
 空白行
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.Comments">
 <summary>
 注释行
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.DynamicsExpression">
 <summary>
 在解释器阶段由于缺少类型信息无法判断目标类型，所以被设置为动态类型
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.FunctionCalls">
 <summary>
 函数调用
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.OutDeviceRef">
 <summary>
 单独执行输出设备的调用
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.FileIO">
 <summary>
 >
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.DynamicsCast">
 <summary>
 &lt;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.Source">
 <summary>
 var &lt;= ${path args} 
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.HybridsScript">
 <summary>
 &lt;&lt; Hybrids scripting;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.HybirdsScriptPush">
 <summary>
 >> Setup variable of hybrids scripting;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.GoTo">
 <summary>
 Goto跳转语句
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.LineLable">
 <summary>
 Goto的跳转的行标
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.OnErrorResumeNext">
 <summary>
 On Error Resume Next语句
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.ExpressionTypes.Wiki">
 <summary>
 ? 符号
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls">
 <summary>
 只是调用方法，函数的返回值直接返回给系统变量$
 方法返回Nothing
 函数返回函数值
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls.EntryPoint">
 <summary>
 对于<see cref="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression.PrimaryExpression"/>类型而言，其不仅仅调用一个方法，而且还将方法的返回值赋值给一个指定的左端变量，
 由于变量之间赋值传递的情况也可能存在，故而这个属性也可能是引用一个内存地址，当找不到方法的时候，就会通过这个参数来查找内存变量
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls.Parameters">
 <summary>
 解析得到的顺序应该和原始的脚本语句是一致的
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls.IsVariable">
 <summary>
 只有左端引用表达式不为空，其他的元素都为空
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel">
 <summary>
 This object just the data model which was generated from the script parser, didn't contains any runtime information.
 (只有解析出来的词元模型，，没有包含有函数指针的句柄信息，还不能够直接运行)
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel.GotoJumpsLabel">
 <summary>
 Value是指向<see cref="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel.Expressions"/>列表之中的元素的位置下表
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel.ScriptParser(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="ScriptText"></param>
 <param name="File">脚本文件的文件路径</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel.ThrowSyntaxException(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.SyntaxError[],System.String)">
 <summary>
 at Shoal.Testing.Debugger.Main() in G:\Shoal\Shoal.Testing\Debugger.vb:line 21
 </summary>
 <param name="Tokens"></param>
 <param name="File"></param>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel.Keywords">
 <summary>
 在<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.SyntaxError"/>的命名空间之下的所有的类型都是脚本之中的关键词
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.MSLTokens">
 <summary>
 Tokenliser working in multiline string literal mode.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.MSLTokens.IsCommentLine">
 <summary>
 当前的整行代码是否为注释行
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.MSLTokens.IsBlank">
 <summary>
 空白行
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.MSLTokens.FinishYet">
 <summary>
 表达式是否已经解析完毕了
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.MSLTokens.Parsing(System.String)">
 <summary>
 将表达式解析为词元，每一个词元都不含有前导或者后置的空白符号
 断词元的条件是Stack必须为空
 </summary>
 <param name="Expression">在调用之前请先试用Trim函数进行处理</param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.FullTokenliser">
 <summary>
 将表达式之中的所有词元进行完全展开
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.TextTokenliser.FullTokenliser.#ctor(System.String)">
 <summary>
 将表达式解析为词元，每一个词元都不含有前导或者后置的空白符号
 断词元的条件是Stack必须为空
 </summary>
 <param name="Expression"></param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName">
 <summary>
 开关参数：只适用于逻辑值参数，有表示True，没有则表示False，开关参数使用-或者--或者\或者/开头
 例如有如下的函数定义
 Function(a As Object, b as Boolean) 
 则调用的时候可以有下面的形式
 Function a $a b T/F/True/False/1/0/yesy/no
 或者开关形式
 Function a $a -b 或者 --b 或者 /b 或者 \b
 当然也可以
 Call $a -> Function True/False/yes/No/1/0/T/F
 Call $a -> Function /a 或者 \a 或者 -a 或者 --a
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType">
 <summary>
 参数名出了普通类型的参数名需要填充参数名之外，其他类型的参数名都可以留空
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType.ExtensionMethodCaller">
 <summary>
 拓展函数的调用参数，即函数定义之中的第一个参数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType.EXtensionSingleParameter">
 <summary>
 当函数有两个参数的时候，使用拓展函数的形式调用，则第二个参数会可以看作为伪单参数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType.SingleParameter">
 <summary>
 函数只有一个参数，则可以忽略参数名直接调用
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType.BooleanSwitch">
 <summary>
 逻辑值类型的开关参数
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType.OrderReference">
 <summary>
 函数的参数之间是按照函数的定义顺序引用的
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.#ctor(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.ParameterName.ParameterType,System.String)">
 <summary>
 
 </summary>
 <param name="Type">普通类型还是特殊类型</param>
 <param name="Expression">获得参数名称的一个表达式字符串</param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable">
 <summary>
 可能会存在指针引用的情况，这个对象类型的主要实现的功能是设置内存变量
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable.RefEntry">
 <summary>
 该变量在内存之中的引用地址
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable.IsInnerReference">
 <summary>
 是内部表达式 <see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.InternalExpression"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="Ref">
 1. Name 普通变量引用
 2. $var 变量地址引用 -> 值是实际的地址
 3. {expr} 内部表达式引用 -> 值是实际的地址
 4. [int] 位置引用
 </param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.LeftAssignedVariable.InternalGetPointer(System.Object)">
 <summary>
 会判断是否为有效的指针
 </summary>
 <param name="Ref"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator">
 <summary>
 该表达式之中的操作符
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.ValueAssign">
 <summary>
 &lt;- Assign value to variable;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.ExtCall">
 <summary>
 -> Extension method calling;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.CollectionOprOrDelegate">
 <summary>
 &lt;= Collection and hash table operations;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.SelfCast">
 <summary>
 = Self type cast;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.HybridsScript">
 <summary>
 &lt;&lt; Hybrids scripting;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.HybirdsScriptPush">
 <summary>
 >> Setup variable of hybrids scripting;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.HashOprOrDelegate">
 <summary>
 => 函数指针
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.DynamicsCast">
 <summary>
 &lt;
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.IODevice">
 <summary>
 >
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.#ctor(System.String)">
 <summary>
 
 </summary>
 <param name="opr">
 [&lt;- Assign value to variable;]
 
 
 [-> Extension method calling;]
 
 
 [&lt;= Collection and hash table operations;]
 
 
 [= Self type cast;]
 
 
 [&lt;&lt; Hybrids scripting;]
 
 
 [>> Setup variable of hybrids scripting;]
 
 </param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.EntryPoint">
 <summary>
 包含有函数句柄以及调用的接口的描述信息
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.InternalExpression">
 <summary>
 这个是参数引用之中的内部表达式，只有单行的
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.InternalExpression.IsExpr">
 <summary>
 是一个表达式，需要进行计算才可以得到值
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.InternalExpression.IsVariable">
 <summary>
 是一个变量
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token">
 <summary>
 一个表达式对象之中的某一个单词元素
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token.OprTag">
 <summary>
 产生<see cref="P:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token.DepthLevel"/>
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token.GetTokenValue">
 <summary>
 获取得到原始的词元数据
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token.GetTrimExpr">
 <summary>
 假若是内部表达式或者变量引用的话，则可以使用这个方法来修建掉两边的括号或者引用的前导符号
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser">
 <summary>
 语法解析器
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.Parsing(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[],System.String)">
 <summary>
 为了提高解析的性能，这里不会使用反射操作来进行解析操作的自动注册的，而是通过在下面的手工排序来得到最好的解析性能
 </summary>
 <param name="Expression"></param>
 <param name="Tokens"></param>
 <param name="Comments"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseRedirectStream(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 @name
 </summary>
 <param name="Expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseDelegate(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 *T &lt;= {
    Imports test
    Return rand
 }
 </summary>
 <param name="Expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseCollectionOpr(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.CollectionOprOrDelegate"/>
 </summary>
 <param name="Expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Compiler.CodeDOM.Expression"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseHybridsScript(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.HybridsScript"/>
 </summary>
 <param name="expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.DynamicsExpression"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseHybirdsScriptPush(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 <see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Operator.Operators.HybirdsScriptPush"/>
 </summary>
 <param name="expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.DynamicsExpression"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseDieException(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 单独的抛出错误的语句
 </summary>
 <param name="expression"></param>
 <param name="Tokens"></param>
 <returns>die &lt;message> when &lt;condition></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseHashTable(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 var = $args => --ssl
 或者
 $args => /name
 </summary>
 <param name="expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseLibrary(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 没有跟随文件名说明是列举出所有安装的模块
 </summary>
 <param name="Expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseInclude(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 Include file1, file2, file3
 </summary>
 <param name="expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseGoto(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 Goto Label When BooleanExpression
 </summary>
 <param name="expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseDynamicsCast(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 var &lt; (typeID) {expression}
 </summary>
 <param name="Expression"></param>
 <param name="Tokens"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseOutputHandle(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 开头的第一个字符必须是$或者&amp;
 </summary>
 <param name="expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseImports(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 
 </summary>
 <param name="expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.TryParseFunctionCalls(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[])">
 <summary>
 </summary>
 <param name="expression">只是用于显示的原始脚本行</param>
 <param name="Tokens">使用这个已经解析好的词元进行<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.FunctionCalls"/></param>对象的生成
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.SyntaxParser.__createParameters(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.Parser.Tokens.Token[],System.Int32)">
 <summary>
 
 </summary>
 <param name="Tokens"></param>
 <param name="Index">
 3:  没有进行拓展方法的调用的
 5:  进行了拓展方法的调用的
 </param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.InternalExtension">
 <summary>
 内部的一些简单的常用命令
 </summary>
 
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.InternalExtension.ScriptSourceHandle">
 <summary>
 脚本的执行入口点的定义
 </summary>
 <param name="Script">脚本中的内容</param>
 <param name="parameters">如果为Nothing，则说明目标脚本的执行不需求参数</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.InternalExtension.List(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 当指定了文件拓展名之后，函数只会返回文件名列表，其他的情况会返回文件名列表和文件夹列表
 </summary>
 <param name="argv"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.InternalExtension.ProcessStart(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 
 </summary>
 <param name="argv"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.InternalExtension.Source(System.String,System.Collections.Generic.KeyValuePair{System.String,System.Object}[])">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.gpl">
<summary>
  Looks up a localized string similar to                     GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away yo [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.index">
<summary>
  Looks up a localized string similar to &lt;!DOCTYPE html&gt;

&lt;html lang=&quot;en&quot;&gt;

	&lt;head&gt;
		
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;%Namespace%&lt;/title&gt;
		
		&lt;style&gt;::-moz-selection {
        background: #b3d4fc;
        text-shadow: none;
      }

      ::selection {
        background: #b3d4fc;
        text-shadow: none;
      }

      html {
        padding: 30px 10px;
        font-size: 16px;
        line-height: 1.4;
        color: #737373;
        background: #f0f0f0;
        -webkit-text-size-adjust: 100%;
        -ms-text-size-adjust: 100%;
      }

  [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.license">
<summary>
  Looks up a localized string similar to This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU  [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.sdk_doc">
<summary>
  Looks up a localized string similar to &lt;!DOCTYPE html&gt;

&lt;html lang=&quot;en&quot;&gt;

	&lt;head&gt;
		
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;%Namespace%&lt;/title&gt;
		
		&lt;style&gt;::-moz-selection {
        background: #b3d4fc;
        text-shadow: none;
      }

      ::selection {
        background: #b3d4fc;
        text-shadow: none;
      }

      html {
        padding: 30px 10px;
        font-size: 16px;
        line-height: 1.4;
        color: #737373;
        background: #f0f0f0;
        -webkit-text-size-adjust: 100%;
        -ms-text-size-adjust: 100%;
      }

  [rest of string was truncated]&quot;;.
</summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.My.Resources.Resources.Shoal">
<summary>
  Looks up a localized resource of type System.Byte[].
</summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryPoint.Name">
 <summary>
 Script name.(混合编程的脚本名称)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryPoint.DataConvertors">
 <summary>
 Basic type data convert interface.(基本数据类型的转换接口)
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryPoint.ConservedString">
 <summary>
 When the <see cref="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.InteropAdapter.Evaluate(System.String)">handlers</see> can not found the data type 
 convert method for the basically type then it will try this system preserved string type convert 
 method to convert the data as string as default.
 (当<see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryPoint.DataConvertors"></see>之中没有查找到目标类型的转换操作接口的时候，则默认使用本方法转换
 为字符串的格式，保留的字符串类型的转换函数)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryPoint.InitInvoke">
 <summary>
 初始化外部环境
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryPoint.IsNull">
 <summary>
This property indicated that the entry data which was parsing from the assembly module is valid or not.(可以使用本属性来判断目标解析数据是否可用)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.DataTransform.#ctor(System.Char,System.Boolean)">
 <summary>
 
 </summary>
 <param name="type">
 数据类型的后缀，推荐：
 $ <see cref="T:System.String"></see>; 
 &amp; <see cref="T:System.Int64"></see>; 
 % <see cref="T:System.Int32"></see>; 
 ? <see cref="T:System.Boolean"></see>; 
 ! <see cref="T:System.Double"></see>; 
 @ <see cref="T:System.DateTime"></see>
 </param>
 <param name="ReservedString">在脚本环境之中必须要有一个保留的字符串转换方法</param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.ScriptEntryPoint">
 <summary>
 与ShellScript进行混合编程的脚本语言，必须要在API的命名空间之中实现这个自定义属性
 </summary>
 <remarks>每一次切换脚本语句环境之前先使用!EntryName来进行，之后直接可以只用左移运算符尽心计算求值</remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.ScriptEntryPoint.#ctor(System.String)">
 <summary>
 设置脚本的名称
 </summary>
 <param name="Language">脚本语言的名称</param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.Evaluation">
 <summary>
 和外部脚本进行编程计算
 </summary>
 <param name="Line">外部脚本的脚本命令行</param>
 <returns>返回所输入的脚本的文本行所执行的结果</returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.SetValue">
 <summary>
 从Shoal语言环境之中向外部脚本环境设置变量的值
 </summary>
 <param name="var">在外部脚本环境之中的变量的名称</param>
 <param name="value">值，需要进行类型转换的</param>
 <returns>是否成功</returns>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.InteropAdapter._Environments">
 <summary>
 小写的键名称
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.InteropAdapter.RedirectStream(System.String)">
 <summary>
 Attach the hybrid scripting environment onto the script host.
 </summary>
 <param name="pointName"></param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.InteropAdapter.Evaluate(System.String)">
 <summary>
 这个函数会自动调用<see cref="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ScriptEngine.Strings"/>进行格式化的
 </summary>
 <param name="script"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryInterface">
 <summary>
 必须要具备两种类型的接口，目标脚本执行环境才会被成功挂载
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryInterface.InterfaceTypes">
 <summary>
 混合编程的接口类型
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryInterface.InterfaceTypes.EntryPointInit">
 <summary>
 有些简单类型可能并不需要初始化过程，所以这一个接口现在是可选的
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryInterface.InterfaceTypes.Evaluate">
 <summary>
 接口类型：Public Function Evaluate(script As String) As Object
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.HybridsScripting.EntryInterface.InterfaceTypes.SetValue">
 <summary>
 Public Function SetValue(variableName As String, value As Object) As Boolean
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.SCOM.RuntimeEnvironment.ScanPlugins(Microsoft.VisualBasic.CommandLine.CommandLine)">
 <summary>
 -scan.plugins -dir &lt;dir>[ -ext *.*/*.dll/*.exe/*.lib /top_only]
 </summary>
 <param name="argvs"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.SCOM.RuntimeComponent">
 <summary>
 This type of the class object consist of the shoal shell scripting engine.
 </summary>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.SCOM.RuntimeComponent.ScriptEngine">
 <summary>
 Script engine.(脚本引擎)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerMessage.MessageTypes.CTRL_PUSH_SCRIPT">
 <summary>
 IDE向Shoal调试程序推送脚本
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerMessage.MessageTypes.CTRL_KILL_SCRIPT">
 <summary>
 IDE发送终止脚本调试的信号
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerMessage.MessageTypes.CTRL_GETS_MEMORY">
 <summary>
 IDE请求Shoal的变量内容
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerMessage.MessageTypes.CTRL_MODIFY_VALUE">
 <summary>
 IDE修改Shoal内存之中的变量的内容
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerMessage.MessageTypes.CTRL_DEBUGGER_INIT_INFO">
 <summary>
 调试客户端向服务器返回初始化信息
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerMessage.MessageTypes.OUTPUT_MESSAGE">
 <summary>
 Shoal向IDE发送一般的消息
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerMessage.MessageTypes.OUTPUT_ERROR">
 <summary>
 Shoal向IDE发送错误消息
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerMessage.MessageTypes.OUTPUT_WARNING">
 <summary>
 Shoal向IDE发送警告消息
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerListener">
 <summary>
 这个对象为服务器对象，运行在IDE模块之中
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerListener.#ctor(System.String,System.String)">
 <summary>
 /debug listener_port &lt;listen_port> [-work &lt;working_Dir>]
 </summary>
 <param name="debugger"></param>
 <param name="WorkDir"></param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.Debugger">
 <summary>
 这个对象是运行于Shoal内部的，用作为调试的客户端的。当IDE启动的时候，会打开调试服务，接着通过命令行启动Shoal程序，将端口号传递给本对象，二者之间通过Tcp协议进行通信
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.Debugger.TcpClient">
 <summary>
 主动向IDE发送调试消息
 </summary>
 <remarks></remarks>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.Debugger.ReadListenerServices">
 <summary>
 监听来自于IDE的控制命令
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.Debugger.#ctor(Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ScriptEngine,System.Int32)">
 <summary>
 
 </summary>
 <param name="ScriptEngine"></param>
 <param name="DebugListenerPort">IDE调试监听器<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerListener"></see>的监听端口号</param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.Debugger.#ctor(Microsoft.VisualBasic.Scripting.ShoalShell.Configuration.Config,System.Int32)">
 <summary>
 
 </summary>
 <param name="Config"></param>
 <param name="DebugListenerPort">IDE调试监听器<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Debugging.DebuggerListener"></see>的监听端口号</param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Dynamics">
 <summary>
 Dynamics programming environment. If the environment thorw member not found exception, then you should consider of the 
 target method namespace may be not registered yet so then you should try using 
 <see cref="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Dynamics.CreateDefaultEnvironment"></see> to initialize the environment.
 (Shoal脚本的动态编程环境，注意：假若提示找不到方法或者空引用，请使用带参数的<see cref="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Dynamics.CreateDefaultEnvironment">
 创建方法</see>在扫描完插件文件夹之后再来创建对象实例)
 
 <see cref="T:System.IConvertible"></see>所返回的是Shoal的系统保留变量的值
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Dynamics.CreateDefaultEnvironment">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Dynamics.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
 <summary>
 首先尝试查看<see cref="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Dynamics._VirtualInvokeAPINsCache"></see>里面的数据，假若没有的话在直接查找，假若有数据，则执行命名空间的连接操作之后在查找执行
 </summary>
 <param name="binder"></param>
 <param name="args">按照函数的定义排序的</param>
 <param name="result"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Dynamics.GetTypeCode">
 <summary>
 Specifies the type of an object.
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DynamicsCast">
 <summary>
 字典之中的Key属性分别为所需要转换的目标类型的简称和输入的第一个参数的类型,目标方法只能够有一个参数
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DynamicsCast.TypeCastDynamics(System.Object,System.String)">
 <summary>
 
 </summary>
 <param name="obj">目标函数的第一个参数，本方法会根据这个参数以及<paramref name="typeId"></paramref>参数查找最合适的句柄来处理本参数的输入</param>
 <param name="typeId">类型标记信息的简写</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DriverHandles.OutputDeviceHandle">
 <summary>
 将目标变量在终端进行输出
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DriverHandles.InputDeviceHandle">
 <summary>
 <see cref="P:System.Attribute.TypeId"></see>参数指的是目标函数所返回的值的类型，驱动程序会自动根据函数的参数的类型来决定函数方法的调用
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DriverHandles.InputDeviceHandle.#ctor(System.String,System.String)">
 <summary>
 
 </summary>
 <param name="TypeId">
 The brief name of the type information, usage syntax of this input type casting driver in the shoal scripting is:  var &lt; (TypeId) $variable
 (类型简称，在脚本之中的使用语法为：  var &lt; (TypeId) $variable)
 </param>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DriverHandles.IO_DeviceHandle">
 <summary>
 Target delegate must compatible with delegate Func(Of T, String, Boolean), the first parameter in the delegate is the 
 data type and the data to write to the file, the second parameter is the file path of the IO operation and the last bool 
 return value indicated that the io operation success or not. please notices that, for the considerations of the data 
 type compatible, the collection data type is recommended implement as generic enumeration interface.
 (目标接口委托对象必须要符合以下接口类型Func(Of T, String, Boolean)，其中第一个将要写文件的数据类型，第二个参数为
 文件路径，最后一个参数是文件是否写入成功，请注意，对于任意的集合类型推荐使用<see cref="T:System.Collections.Generic.IEnumerable`1"></see>泛型集合)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.DriverHandles.IO_DeviceHandle.#ctor(System.Type)">
 <summary>
 
 </summary>
 <param name="DataType">目标数据类型，脚本引擎会自动根据函数的数据类型自动选择文件系统的写入方式的驱动程序</param>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.IODeviceDriver.ImportsHandler(System.Type)">
 <summary>
 返回成功导入的IO方法
 </summary>
 <param name="Module"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.IODeviceDriver.WriteData(System.Object,System.String)">
 <summary>
 This function will trying to save the data in a properly method from the data type:
 Function will trying save the string as a text file;
 Basic data type collection will be save as a csv data table;
 All of the other data type will be saved based on the registry data;
 If the method is not found in the registry for the data type, then function will throw a method missing exception!
 (函数会尝试根据文件的类型来选择合适的保存格式:
 字符串类型会保存为文本文件
 数组会保存为Csv
 其他的复杂类型会尝试根据注册的句柄来执行相应的数据保存操作)
 </summary>
 <param name="value"></param>
 <param name="path"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.DeviceDriver.OutputDeviceDriver">
 <summary>
 Output support module for that data type.(各种数据类型的输出模块)
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.PageMapping.MappingImports.Imports(System.Reflection.TypeInfo,System.Boolean)">
 <summary>
 只会绑定非实例的属性或者域
 </summary>
 <param name="Assembly"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.PageMapping.MappingImports.__imports(System.Reflection.TypeInfo)">
 <summary>
 只会绑定非实例的属性或者域
 </summary>
 <param name="Assembly"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.IPageUnit.REM">
 <summary>
 在使用变量申明语句的时候的注释信息
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.IPageUnit.TypeOf">
 <summary>
 得到变量的值的当前的数据类型
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.IPageUnit.View">
 <summary>
 详细信息
 </summary>
 <returns></returns>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.IPAGE_TYPES.MMU">
 <summary>
 Variable
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.IPAGE_TYPES.SMMU">
 <summary>
 Constant
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.PageUnitView.View(Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.IPageUnit)">
 <summary>
 详细信息
 </summary>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Strings">
 <summary>
 字符串服务
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Strings.Format(System.String)">
 <summary>
 常量是区分大小写的
 </summary>
 <param name="Expr"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice">
 <summary>
 Memory Management Unit Device.(大小写不敏感的，直接使用即可)
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.MMU_CHUNKS">
 <summary>
 内存设备
 </summary>
</member>
<member name="F:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.MTRR">
 <summary>
 寄存器
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.SystemReserved">
 <summary>
 内存之中的地址总是 0; <see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Return"/>函数会写入返回数据到这个保留变量之中
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.__importsConstantsInit">
 <summary>
 导入系统初始的默认常量
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.__addInternal(System.String,Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.IPageUnit@)">
 <summary>
 
 </summary>
 <param name="keyFind">必须为小写的</param>
 <param name="var"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.ImportConstant(System.String,System.Object,System.String)">
 <summary>
 常量是大小写敏感的，但是变量大小写不敏感
 </summary>
 <param name="Name">不需要加前导符号</param>
 <param name="value"></param>
 <param name="Type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.InitLocals(System.String,System.Object,System.String)">
 <summary>
 函数会返回该新申请的变量的内存之中的地址
 </summary>
 <param name="Name"></param>
 <param name="value"></param>
 <param name="Type"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.Allocate(Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.IPageUnit)">
 <summary>
 为新的变量分配新的内存区域
 </summary>
 <param name="var"></param>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.MMUDevice.GetPageUnit(System.String)">
 <summary>
 请不要删除前面的前导符号，这个方法会优先读取映射的内存不，但是更新的时候会两个部分都会更新掉
 </summary>
 <param name="hashKey"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Variable.AddrHwnd">
 <summary>
 内存之中的位置指针，使用 *p 来表示
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Variable.REM">
 <summary>
 在使用变量申明语句的时候的注释信息
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Variable.TypeOf">
 <summary>
 得到变量的值的当前的数据类型
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Variable.#ctor">
 <summary>
 For Serialization
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.MMU.Variable.#ctor(System.String,System.String,System.Object,System.Boolean)">
 <summary>
 
 </summary>
 <param name="Name"></param>
 <param name="Type"></param>
 <param name="[ReadOnly]">是否为常量</param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.FSMMachine">
 <summary>
 执行整个脚本的模块
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.FSMMachine.#ctor(Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ScriptEngine,Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.SyntaxModel)">
 <summary>
 Initialize a runtime state machine for running a script file.
 </summary>
 <param name="ScriptEngine"></param>
 <param name="Script"></param>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.FSMMachine.Execute">
 <summary>
 已经包含有错误处理的代码了，由于这个是执行的是脚本文件，故而出错的时候会直接退出运行
 </summary>
 <returns></returns>
 <remarks>Dirty works here in this function.</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.FSMMachine.__execute(System.Boolean@)">
 <summary>
 
 </summary>
 <param name="__return">是否执行了<see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.Keywords.Return"/>代码</param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ScriptEngine">
 <summary>
 Shoal Shell script Engine, you can using this object to embedded a script engine into 
 your application or using this script engine as a powerfully debugging tool.
 Try using <see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.Dynamics"/> object to dynamics programming in your .NET program.
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ScriptEngine.MMUDevice">
 <summary>
 Shoal Shell memory management device.
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ScriptEngine.Strings">
 <summary>
 String interpolated services.(字符串服务)
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ScriptEngine.#ctor">
 <summary>
 采用默认的配置文件数据来初始化脚本引擎
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ScriptEngine.Exec(System.String)">
 <summary>
 处理来自于终端输入的一行脚本代码
 </summary>
 <param name="Script"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ScriptEngine.Source(System.String)">
 <summary>
 处理来自于文件之中的脚本代码
 </summary>
 <param name="path"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel">
 <summary>
 执行依据脚本语句
 </summary>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.Execute">
 <summary>
 ShoalShell <see cref="T:Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression"/> evaluation.
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.Exec(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 出于性能方面的考虑，这个执行函数是没有进行任何错误处理的
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.Delegate(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 在入口点管理器之中生成一个匿名函数
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.DynamicsExpression(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 在解释器阶段由于缺少类型信息无法判断目标类型，所以被设置为动态类型
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.__fillBool(System.Reflection.ParameterInfo[])">
 <summary>
 逻辑值默认为False
 </summary>
 <param name="params"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.FunctionCalls(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 函数调用。函数的执行级别优先于Delegate函数指针
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.OutDeviceRef(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 单独执行输出设备的调用，在终端输出或者打开绘图窗口
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.HybridsScript(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 &lt;&lt; Hybrids scripting;
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.HybirdsScriptPush(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 >> Setup variable of hybrids scripting;
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.FileIO(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 > 操作符将数据写入文件
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.GoTo(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 Goto跳转语句
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.Cd(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 ~ 是主文件夹的简写
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.Library(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 动态注册一个链接库，在进行挂载
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.__libraries">
 <summary>
 列举出所有已经注册的动态链接库
 </summary>
 <returns></returns>
 <remarks></remarks>
 
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.Runtime.ExecuteModel.Memory(Microsoft.VisualBasic.Scripting.ShoalShell.Interpreter.LDM.Expressions.PrimaryExpression)">
 <summary>
 Memory [varName]
 </summary>
 <param name="Expression"></param>
 <returns></returns>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Assembly">
 <summary>
 用于引用的程序的定位的，用来处理相对路径以及网络路径
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Assembly.TypeId">
 <summary>
 这个属性使用于记录重复的命名空间模块之间的相互比较的
 路径可以不一样，但是这个必须要一样
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Assembly.GetType">
 <summary>
 Gets this partial module defined type information.
 </summary>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Assembly.LoadAssembly">
 <summary>
 出错的时候会返回空值
 </summary>
 <returns></returns>
 <remarks>请注意，在执行的时候可能当前的工作目录会发生改变，所以计算相对路径的时候总是需要以当前的程序的位置来计算</remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.PartialModule.Copy(Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.PartialModule)">
 <summary>
 从文件之中解析出来的新的数据更新当前的模块
 </summary>
 <param name="ns"></param>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.EntryPointMeta">
 <summary>
 一个方法的元数据
 </summary>
 <remarks></remarks>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.AssemblyParser.LoadAssembly(System.String)">
 <summary>
 解析出错或返回空集合并在终端上面打印出错误信息
 </summary>
 <param name="Path">不需要特殊处理，函数会自动转换为全路径</param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.AssemblyParser.Imports(System.Type)">
 <summary>
 直接导入静态方法
 </summary>
 <param name="[module]"></param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Namespace.PartialModules">
 <summary>
 命名空间是可以被分隔为多个模块分别开发于不同的程序模块之中的
 </summary>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Namespace.Description">
 <summary>
 A brief description text about the function of this namespace.(关于本模块之中的描述性的摘要文本)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.Namespace.Namespace">
 <summary>
 The name value of this namespace module.(本命名空间模块的名称值)
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.PackageModuleDb">
 <summary>
 包管理器的数据库文件
 </summary>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.PackageModuleDb.DefaultFile">
 <summary>
 默认的注册表配置文件，该文件是在与本程序同一个文件夹之下的以程序名开始的XML文件.在该文件之中包含有所有的类型注册信息
 </summary>
 <remarks></remarks>
</member>
<member name="T:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.ShoalPackageManager">
 <summary>
 Shoal模块管理器
 </summary>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.ShoalPackageManager.MergeNamespace(Microsoft.VisualBasic.Scripting.ShoalShell.SPM.Nodes.PartialModule[])">
 <summary>
 将所得到的模块合并到现有的模块之中
 </summary>
 <param name="NsCollection"></param>
 <returns></returns>
</member>
<member name="M:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.ShoalPackageManager.Imports(System.String)">
 <summary>
 向脚本环境之中安装注册一个外部的模块
 </summary>
 <param name="assemPath">文件路径不需要特殊处理，函数会自动转换为全路径</param>
 <returns></returns>
</member>
<member name="P:Microsoft.VisualBasic.Scripting.ShoalShell.SPM.ShoalPackageManager.Item(System.String)">
 <summary>
 大小写不敏感
 </summary>
 <param name="key"></param>
 <returns></returns>
</member>
</members>
</doc>
